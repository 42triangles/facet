{# Template for generating Shapely implementations for tuples #}

{# Note: this comment applies not to this template file, but to the generated code #}
//! GENERATED: DO NOT EDIT â€” this file is generated from `tuples_impls.rs.j2`
//! file in the `shapely-codegen` crate.

use std::{alloc::Layout, fmt};

use crate::{Field, FieldFlags, Def, StructDef, Shape, Shapely, TypeNameOpts, ValueVTable, Characteristic, OpaqueConst};

macro_rules! field {
    ($idx:tt, $ty:ty,) => {
        Field {
            name: stringify!($idx),
            shape: <$ty>::SHAPE,
            offset: std::mem::offset_of!($ty, $idx),
            flags: FieldFlags::EMPTY,
        }
    };
}

{% for n in range(1, max_tuple_size + 1) %}
    {%- set where_predicates %}{% for i in range(n) %}T{{ i }}: Shapely{% if not loop.last %},{% endif %}{% endfor %}{% endset %}
    {%- set type_list %}
        {%- for i in range(n) -%}
        T{{ i }}{% if not loop.last %}, {% endif %}
        {%- endfor -%}
    {%- endset %}
    {%- set type_name %}
        ({%- for i in range(n) %}T{{ i }},{% endfor -%})
    {%- endset -%}
unsafe impl<{{ type_list }}> Shapely for {{ type_name }}
where
    {{ where_predicates }}
{
    const DUMMY: Self = (
        {% for i in range(n) %}T{{ i }}::DUMMY,{% endfor %}
    );
    const SHAPE: &'static Shape = &const {
        fn type_name<{{ type_list }}>(
            f: &mut fmt::Formatter,
            opts: TypeNameOpts,
        ) -> fmt::Result
        where
            {{ where_predicates }}
        {
            shapely_types::write_type_name_list(
                f,
                opts,
                "(",
                ", ",
                ")",
                &[{{ type_list }}]
            )
        }

        Shape {
            layout: Layout::new::<{{ type_name }}>(),
            vtable: &ValueVTable {
                type_name: type_name::<{{ type_list }}>,
                display: None,
                debug: const {
                    if Characteristic::Debug.all(&[
                        {% for i in range(n) %}T{{ i }}::SHAPE{% if not loop.last %},
                        {% endif %}{% endfor %}
                    ]) {
                        Some(|value, f| {
                            let value = unsafe { value.as_ref::<{{ type_name }}>() };
                            write!(f, "(")?;
                            {% for i in range(n) %}{% if i > 0 %}write!(f, ", ")?;
                            {% endif %}unsafe {
                                (T{{ i }}::SHAPE.vtable.debug.unwrap_unchecked())(
                                    OpaqueConst::from_ref(&value.{{ i }}),
                                    f,
                                )
                            }?;{% endfor %}
                            write!(f, ")")
                        })
                    } else {
                        None
                    }
                },
                eq: if {% for i in range(n) %}{% if i > 0 %} && {% endif %}T{{ i }}::SHAPE.vtable.eq.is_some(){% endfor %} {
                    Some(|a, b| {
                        let a = unsafe { a.as_ref::<{{ type_name }}>() };
                        let b = unsafe { b.as_ref::<{{ type_name }}>() };

                        {% for i in range(n) %}{% if i < n-1 %}// Compare element {{ i }}
                        if !unsafe {
                            (T{{ i }}::SHAPE.vtable.eq.unwrap_unchecked())(
                                OpaqueConst::from_ref(&a.{{ i }}),
                                OpaqueConst::from_ref(&b.{{ i }}),
                            )
                        } {
                            return false;
                        }

                        {% elif i == n-1 %}// Compare last element
                        unsafe {
                            (T{{ i }}::SHAPE.vtable.eq.unwrap_unchecked())(
                                OpaqueConst::from_ref(&a.{{ i }}),
                                OpaqueConst::from_ref(&b.{{ i }}),
                            )
                        }{% endif %}{% endfor %}
                    })
                } else {
                    None
                },
                // ... (other vtable fields)
            },
            def: Def::Tuple(StructDef {
                fields: &const { [
                    {% for i in range(n) %}field!({{ i }}, {{ type_name }},){% if not loop.last %},
                    {% endif %}{% endfor %}
                ] },
            }),
        }
    };
}
{% endfor %}
