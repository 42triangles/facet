{# Template for generating Shapely implementations for tuples #}

use std::{alloc::Layout, fmt};

use crate::{Field, FieldFlags, Def, StructDef, Shape, Shapely, TypeNameOpts, ValueVTable, Characteristic, OpaqueConst};

{% for n in range(1, max_tuple_size + 1) %}
    {%- set where_predicates %}{% for i in range(n) %}T{{ i }}: Shapely{% if not loop.last %},{% endif %}{% endfor %}{% endset %}
    {%- set type_list %}
        {%- for i in range(n) -%}
        T{{ i }}{% if not loop.last %}, {% endif %}
        {%- endfor -%}
    {%- endset %}
    {%- set type_name %}
        ({%- for i in range(n) %}T{{ i }},{% endfor -%})
    {%- endset -%}
unsafe impl<{{ type_list }}> Shapely for {{ type_name }}
where
    {{ where_predicates }}
{
    const DUMMY: Self = (
        {% for i in range(n) %}T{{ i }}::DUMMY,{% endfor %}
    );
    const SHAPE: &'static Shape = &const {
        fn type_name<{{ type_list }}>(
            f: &mut fmt::Formatter,
            opts: TypeNameOpts,
        ) -> fmt::Result
        where
            {{ where_predicates }}
        {
            if let Some(opts) = opts.for_children() {
                write!(f, "(")?;
                {% for i in range(n) %}{% if i > 0 %}write!(f, ", ")?;
                {% endif %}(T{{ i }}::SHAPE.vtable.type_name)(f, opts)?;{% endfor %}
                write!(f, ")")
            } else {
                write!(f, "â‹¯")
            }
        }

        macro_rules! field {
            ($idx:tt, $ty:ty) => {
                Field {
                    name: stringify!($idx),
                    shape: <$ty>::SHAPE,
                    offset: std::mem::offset_of!({{ type_name }}, $idx),
                    flags: FieldFlags::EMPTY,
                }
            };
        }

        Shape {
            layout: Layout::new::<{{ type_name }}>(),
            vtable: &ValueVTable {
                type_name: type_name::<{{ type_list }}>,
                display: None,
                debug: const {
                    if Characteristic::Debug.all(&[
                        {% for i in range(n) %}T{{ i }}::SHAPE{% if not loop.last %},
                        {% endif %}{% endfor %}
                    ]) {
                        Some(|value, f| {
                            let value = unsafe { value.as_ref::<{{ type_name }}>() };
                            write!(f, "(")?;
                            {% for i in range(n) %}{% if i > 0 %}write!(f, ", ")?;
                            {% endif %}unsafe {
                                (T{{ i }}::SHAPE.vtable.debug.unwrap_unchecked())(
                                    OpaqueConst::from_ref(&value.{{ i }}),
                                    f,
                                )
                            }?;{% endfor %}
                            write!(f, ")")
                        })
                    } else {
                        None
                    }
                },
                eq: if {% for i in range(n) %}{% if i > 0 %} && {% endif %}T{{ i }}::SHAPE.vtable.eq.is_some(){% endfor %} {
                    Some(|a, b| {
                        let a = unsafe { a.as_ref::<{{ type_name }}>() };
                        let b = unsafe { b.as_ref::<{{ type_name }}>() };

                        {% for i in range(n) %}{% if i < n-1 %}// Compare element {{ i }}
                        if !unsafe {
                            (T{{ i }}::SHAPE.vtable.eq.unwrap_unchecked())(
                                OpaqueConst::from_ref(&a.{{ i }}),
                                OpaqueConst::from_ref(&b.{{ i }}),
                            )
                        } {
                            return false;
                        }

                        {% elif i == n-1 %}// Compare last element
                        unsafe {
                            (T{{ i }}::SHAPE.vtable.eq.unwrap_unchecked())(
                                OpaqueConst::from_ref(&a.{{ i }}),
                                OpaqueConst::from_ref(&b.{{ i }}),
                            )
                        }{% endif %}{% endfor %}
                    })
                } else {
                    None
                },
                // ... (other vtable fields)
            },
            def: Def::Tuple(StructDef {
                fields: &const { [
                    {% for i in range(n) %}field!({{ i }}, T{{ i }}){% if not loop.last %},
                    {% endif %}{% endfor %}
                ] },
            }),
        }
    };
}
{% endfor %}
